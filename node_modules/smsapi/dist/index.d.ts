import { AxiosInstance } from 'axios';

declare class BaseModule {
    protected httpClient: AxiosInstance;
    constructor(httpClient: AxiosInstance);
}

interface ApiCollection<T> {
    collection: T[];
    size: number;
}

type ContactGender = 'female' | 'male' | 'undefined';

interface Contact {
    id: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    email: string;
    gender: ContactGender;
    birthdayDate: Date;
    description: string;
    city: string;
    source: string;
}

interface NewContact {
    firstName?: string;
    lastName?: string;
    email?: string;
    gender?: ContactGender;
    birthdayDate?: Date;
    description?: string;
    city?: string;
    source?: string;
}

interface GetContactsQueryParams {
    q?: string;
    offset?: number;
    limit?: number;
    orderBy?: 'first_name' | 'last_name' | 'date_updated' | 'date_created';
    phoneNumber?: string | string[];
    email?: string | string[];
    firstName?: string | string[];
    lastName?: string | string[];
    groupId?: string | string[];
    gender?: ContactGender;
    birthdayDate?: Date | Date[];
}

interface CreateGroupDetails {
    description?: string;
    idx?: string;
    contactExpireAfter?: number;
}

interface GroupPermission {
    groupId: string;
    username: string;
    write: boolean;
    read: boolean;
    send: boolean;
}

interface Group {
    id: string;
    name: string;
    description: string;
    contactsCount: number;
    dateCreated: Date;
    dateUpdated: Date;
    createdBy: string;
    idx: string | null;
    permissions: GroupPermission[];
}

interface UpdateGroup extends Partial<CreateGroupDetails> {
    name?: string;
}

declare class Groups extends BaseModule {
    get(): Promise<ApiCollection<Group>>;
    getById(groupId: string): Promise<Group>;
    create(name: string, details?: CreateGroupDetails): Promise<Group>;
    update(groupId: string, updateGroup: UpdateGroup): Promise<Group>;
    remove(groupId: string, deleteContacts?: boolean): Promise<void>;
}

interface UpdateContact extends NewContact {
    phoneNumber?: string;
}

type FieldType = 'text' | 'date' | 'email' | 'phone_number' | 'number';

interface Field {
    id: string;
    name: string;
    type: FieldType;
}

declare class Fields extends BaseModule {
    get(): Promise<ApiCollection<Field>>;
    create(fieldName: string, fieldType?: FieldType): Promise<Field>;
    update(fieldId: string, newName: string): Promise<Field>;
    remove(fieldId: string): Promise<void>;
}

declare class Contacts extends BaseModule {
    private contactHttpClient;
    fields: Fields;
    groups: Groups;
    constructor(httpClient: AxiosInstance);
    get(params?: GetContactsQueryParams): Promise<ApiCollection<Contact>>;
    getById(contactId: string): Promise<Contact>;
    create(phoneNumber: string, details?: NewContact): Promise<Contact>;
    update(contactId: string, updateContact: UpdateContact): Promise<Contact>;
    remove(contactId: string): Promise<void>;
    getGroups(contactId: string): Promise<ApiCollection<Group>>;
    getGroupById(contactId: string, groupId: string): Promise<Group>;
    assignContactToGroup(contactId: string, groupId: string): Promise<ApiCollection<Group>>;
    unpinContactFromGroup(contactId: string, groupId: string): Promise<void>;
    private formatContactDetails;
}

interface HlrCheck {
    id: string;
    number: string;
    price: number;
    status: 'OK';
}

interface HlrCheckError {
    number: string;
    status: 'ERROR';
    error: number;
}

type HlrCheckResponse = HlrCheck | HlrCheckError;

declare class Hlr extends BaseModule {
    check(numbers: string | string[], idx?: string | string[]): Promise<HlrCheckResponse | HlrCheckResponse[]>;
}

interface BaseMessageDetails {
    date?: Date;
    idx?: string;
    checkIdx?: boolean;
    notifyUrl?: string;
    test?: boolean;
}

type SmsEncoding = 'iso-8859-1' | 'iso-8859-2' | 'iso-8859-3' | 'iso-8859-4' | 'iso-8859-5' | 'iso-8859-7' | 'windows-1250' | 'windows-1251' | 'utf-8';
interface SmsDetails extends BaseMessageDetails {
    from?: string | '2way';
    encoding?: SmsEncoding;
    flash?: boolean;
    timeRestriction?: 'follow' | 'ignore' | 'nearest_available';
    udh?: string;
    skipForeign?: boolean;
    allowDuplicates?: boolean;
    checkIdx?: boolean;
    noUnicode?: boolean;
    normalize?: boolean;
    fast?: boolean;
    partnerId?: string;
    maxParts?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
    expirationDate?: Date;
    discountGroup?: string;
    param1?: string;
    param2?: string;
    param3?: string;
    param4?: string;
    template?: string;
    datacoding?: 'bin';
}

type MessageStatus = 'ACCEPTED' | 'DELIVERED' | 'EXPIRED' | 'FAILED' | 'NOT_FOUND' | 'QUEUE' | 'REJECTED' | 'RENEWAL' | 'SENT' | 'STOP' | 'UNDELIVERED' | 'UNKNOWN';

interface ApiMessageResponse {
    count: number;
    list: {
        id: string;
        points: number;
        number: string;
        dateSent: number;
        submittedNumber: string;
        status: MessageStatus;
        idx: string | null;
        parts?: number;
    }[];
    message?: string;
    length: number;
    parts?: number;
}
interface MessageResponse extends Omit<ApiMessageResponse, 'list'> {
    list: {
        id: string;
        points: number;
        number: string;
        dateSent: Date;
        submittedNumber: string;
        status: MessageStatus;
        idx: string | null;
        parts?: number;
    }[];
}

type VmsTtsLector = 'ewa' | 'jacek' | 'jan' | 'maja';

interface SmsContent {
    message: string;
}
interface MmsContent {
    smil: string;
    subject: string;
}
interface VmsTextContent {
    tts: string;
    ttsLector?: VmsTtsLector;
}
interface VmsLocalFileContent {
    localPath: string;
}
interface VmsRemoteFileContent {
    remotePath: string;
}
type MessageContent = MmsContent | SmsContent | VmsLocalFileContent | VmsRemoteFileContent | VmsTextContent;

interface NumberRecipient {
    to: string | string[];
}
interface GroupRecipient {
    group: string | string[];
}
type Recipient = NumberRecipient | GroupRecipient;
declare class BaseMessageModule extends BaseModule {
    protected endpoint: string;
    protected send(content: MessageContent, recipient: Recipient, details?: SmsDetails): Promise<MessageResponse>;
    private isNumberRecipient;
    private isGroupRecipient;
    private isSms;
    private isMms;
    private isVmsText;
    private isVmsLocalFile;
    private isVmsRemotePath;
    private getFormDataForVmsLocalFile;
    private formatSmsDetails;
    protected formatResponse(response: ApiMessageResponse): MessageResponse;
}

type MmsDetails = BaseMessageDetails;

declare class Mms extends BaseMessageModule {
    endpoint: string;
    sendMms(numbers: string | string[], subject: string, smil: string, details?: MmsDetails): Promise<MessageResponse>;
    sendMmsToGroup(groups: string | string[], subject: string, smil: string, details?: MmsDetails): Promise<MessageResponse>;
}

type PaymentType = 'prepaid' | 'postpaid' | 'subscription' | 'trial';

interface ProfileResponse {
    id: string;
    name: string;
    email: string;
    username: string;
    phoneNumber: string;
    paymentType: PaymentType;
    userType: 'native' | 'subuser';
    points?: number;
}

declare class Profile extends BaseModule {
    get(): Promise<ProfileResponse>;
}

interface SubuserCredentials {
    username: string;
    password: string;
    apiPassword?: string;
}

interface SubuserPoints {
    fromAccount: number;
    perMonth: number;
}

interface NewSubuser {
    credentials: SubuserCredentials;
    active?: boolean;
    description?: string;
    points?: SubuserPoints;
}

interface NewTemplate {
    name: string;
    template: string;
    normalize?: boolean;
}

interface ScheduledSmsResponse {
    count: number;
    list: {
        id: string;
    }[];
}

type SendernameStatus = 'ACTIVE' | 'INACTIVE' | 'DELETED' | 'PENDING' | 'REJECTED';

interface Sendername {
    createdAt: Date;
    isDefault: boolean;
    sender: string;
    status: SendernameStatus;
}

interface Subuser {
    id: string;
    username: string;
    active: boolean;
    description: string | null;
    points: SubuserPoints;
}

interface Template {
    id: string;
    name: string;
    template: string;
}

interface UpdateSubuser {
    credentials: Partial<Omit<SubuserCredentials, 'username'>>;
    active: boolean;
    description: string;
    points: Partial<SubuserPoints>;
}

interface MessageErrorResponse {
    error: number;
    message: string;
}

declare class Sendernames extends BaseModule {
    get(): Promise<ApiCollection<Sendername>>;
    getBySender(sender: string): Promise<Sendername>;
    create(sender: string): Promise<Sendername>;
    makeDefault(sender: string): Promise<void>;
    remove(sender: string): Promise<void>;
    private formatSendernameDates;
}

declare class Sms extends BaseMessageModule {
    endpoint: string;
    sendSms(numbers: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    sendFlashSms(numbers: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    sendSmsToGroup(groups: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    sendFlashSmsToGroup(groups: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    removeScheduledSms(smsId: string | string[]): Promise<ScheduledSmsResponse>;
}

declare class Subusers extends BaseModule {
    get(): Promise<ApiCollection<Subuser>>;
    getById(subuserId: string): Promise<Subuser>;
    create(newSubuser: NewSubuser): Promise<Subuser>;
    update(subuserId: string, updateSubuser: Partial<UpdateSubuser>): Promise<Subuser>;
    remove(subuserId: string): Promise<void>;
}

declare class Templates extends BaseModule {
    get(): Promise<ApiCollection<Template>>;
    getById(templateId: string): Promise<Template>;
    create(newTemplate: NewTemplate): Promise<Template>;
    update(templateId: string, newTemplate: Partial<NewTemplate>): Promise<Template>;
    remove(templateId: string): Promise<void>;
}

interface VmsDetails extends BaseMessageDetails {
    try?: 1 | 2 | 3 | 4 | 5 | 6;
    interval?: number;
    skipGsm?: boolean;
}

declare class Vms extends BaseMessageModule {
    endpoint: string;
    sendVms(numbers: string | string[], tts: string, ttsLector?: VmsTtsLector, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithLocalFile(numbers: string | string[], pathToLocaleFile: string, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithRemoteFile(numbers: string | string[], pathToRemoteFile: string, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsToGroup(groups: string | string[], tts: string, ttsLector?: VmsTtsLector, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithLocalFileToGroup(groups: string | string[], pathToLocaleFile: string, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithRemoteFileToGroup(groups: string | string[], pathToRemoteFile: string, details?: VmsDetails): Promise<MessageResponse>;
}

declare class SMSAPI {
    private accessToken;
    private httpClient;
    contacts: Contacts;
    hlr: Hlr;
    mms: Mms;
    profile: Profile;
    sendernames: Sendernames;
    sms: Sms;
    subusers: Subusers;
    templates: Templates;
    vms: Vms;
    constructor(accessToken: string);
    private getUserAgent;
    private setHttpClient;
}

export { type ApiCollection, type HlrCheck, type HlrCheckError, type HlrCheckResponse, type MessageErrorResponse, type MessageResponse, type MessageStatus, type MmsDetails, type NewSubuser, type NewTemplate, type PaymentType, type ProfileResponse, SMSAPI, type ScheduledSmsResponse, type Sendername, type SendernameStatus, type SmsDetails, type Subuser, type SubuserCredentials, type SubuserPoints, type Template, type UpdateSubuser };
